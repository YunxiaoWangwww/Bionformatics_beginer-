#suppose we want to find the evening regulatory element in the genome for circadian cycle, we found some genes that are upregulated during circadian cycle and put them in an array called Dna 
#Dna is an array of strings with equal length 
#loop through the first string of Dna and assign each k-mer in the first string into a list called Motifs -> this will be used as the reference for comparison between other strings (1:len(Dna))
#assign every first k-mer in each string of Dna into a list called BestMotifs
#Motifs[0] will be used to calculate the Profile frequency -> this is used for comparing with other k-mers in Dna[1] and find the best matched sequence, then compare with Dna[2] (using the profile frequency generated by Dna[0] and Dna[1]) to find the best matched sequence, and so on…
#these best matched sequence for Motifs[0] will be assigned into the Motif array (after the element Motifs[0] sequence) and they all will be used to calculate the Profile array and find the consensus sequence -> score of all bases that each motif is different from the consensus is calculated, the lower the score, the more conserved the motif sequences are
#after finding the score for Motifs[0], repeat the same step for Motif[1],[2], and so on… Motifs list will be renewed in every run 
#compare score between Motifs[0] and Motifs[1], assign the smaller one to the BestMotifs array (which is updated already by Motifs[0] in the first run)
#the algorithm will output the most conserved k-mer in a Dna array based on that the conserved k-mer presents in the first string of the Dna 

#the function Pr will calculate the probability that one given sequence is a concensus sequence, based on the Profile motifs which is an array of motifs where the most frequent base in each column of the array will be the consensus base at that column position
def Pr(Text,Profile):
    p = 1
    for i in range(len(Text)):
        p = Profile[Text[i]][i]*p 
    return p

#find the consensus k-mer -> as Pr outputs probability of each k-mer in the Dna array, this function outputs the one with the highest probability 
def ProfileMostProbableKmer(text, k, profile):
    pr = {}
    for i in range(len(text)-k+1):
        sequence = text[i:i+k]
        pr[i] = Pr(sequence,profile)
    indice = max(pr, key=pr.get)
    output = text[indice:indice+k]
    return output    

#output the Profile frequency of motifs (an array with strings of the same length) -> the frequency of A,T,C,G in each position of a k-mer based on these motifs
def Profile(Motifs):
    count = {}
    k = len(Motifs[0])
    for symbol in "ACGT":
        count[symbol] = []
        for j in range(k):
             count[symbol].append(1)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            count[symbol][j] += 1/t+4
    return count   

#output the consensus sequence for an array of Motifs -> each base is with the highest frequency in each position of the consensus sequence
def Consensus(Motifs):
    k = len(Motifs[0])
    count = Profile(Motifs)
    consensus = ""
    for j in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if count[symbol][j] > m:
                m = count[symbol][j]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus

#scores are the sum of all bases in the motifs different from the consensus for an given position
def Score(Motifs):
    score = 0
    consensus = Consensus(Motifs)
    for j in range(len(consensus)):
        for k in range(len(Motifs)):
            if consensus[j] != Motifs[k][j]:
                score += 1
    return score

#the algorithm will output the most conserved k-mer in a Dna array based on that the conserved k-mer presents in the first string of the Dna 
def GreedyMotifSearch(Dna,k,t):
    BestMotifs = []
    for i in range(0, t):
        BestMotifs.append(Dna[i][0:k])
    n = len(Dna[0])
    for m in range(n-k+1):
        Motifs = []
        Motifs.append(Dna[0][m:m+k])
        for j in range(1, t):
            P = Profile(Motifs[0:j])
            Motifs.append(ProfileMostProbableKmer(Dna[j], k, P))
        if Score(Motifs) < Score(BestMotifs):
            BestMotifs = Motifs
    return BestMotifs
#loop over the file and put each line (defined by the “/n”)  into an array used for generating the motifs 
Dna = []
with open("TB_DosR.txt", 'r') as f:
    for line in f:
        Dna.append(line[0:len(line)-1]) #the last position in each line is /n and we want to exclude it by minus 1
f.close()
results = GreedyMotifSearch(Dna,15,10)
print(results)















